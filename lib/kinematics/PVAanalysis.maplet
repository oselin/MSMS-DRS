
with(MBSymba_r6):
with(LinearAlgebra):

# Position
# Plot the open and closed configurations
printf("\nThe open and closed configurations are"):
A := draw_mech(sol_kine, data, theta3(t)=flap_closed, title = "Configuration Recursive", size = [500,500]):
B := draw_mech(sol_kine, data, theta3(t)=flap_open  , title = "Configuration Recursive", size = [500,500]):
plots[display](Array([A, B])):print(%):

# Animate the mechanism
printf("The mechanism animation is"):
animate(draw_mech, [sol_kine, data, theta3(t) = q1_profile], T = 0..3*actuation_time);
print(%):

# Plot the dependent variables
A := plot(subs(sol_kine, data, theta3(t) = q1_profile, theta1(t) * 180 /Pi), T = 0..3*actuation_time, color = c_set[1],
     title = typeset("Velocity ", theta__1(t)),labels=[t (s),typeset("Angle", [°])],size = [800, 500]):
B := plot(subs(sol_kine, data, theta3(t) = q1_profile, s(t)), T = 0..3*actuation_time, color = c_set[2],
     title = typeset("Velocity ", s(t)),labels=[t (s),typeset([m])],size = [800, 500]):

plots[display](Array([A, B])):print(%):
# Velocity
# Velocity ratios
JPhiD := jacobianF(Phi,q_D);
JPhiI := jacobianF(Phi, q_I);
printf("\nThe velocity ratios are"):
tau_mat := -MatrixInverse(JPhiD).JPhiI;
print(%):
# Calculate and plot the velocities
diff(Phi, t):

printf("\nThe velocities are"):
sol_vel := op(solve(%, diff(q_D, t))):
print(<%>):

vel_theta1 := subs(sol_vel,diff(theta1(t),t)):
vel_s      := subs(sol_vel,diff(s(t),t)):

theta_base := {theta3(t)=q1_profile, diff(theta3(t),t)=diff(q1_profile,T),diff(theta3(t),t,t)=diff(q1_profile,T,T)}:

A := plot(subs(sol_kine, data, theta_base, vel_theta1), T = 0..3*actuation_time, color = c_set[1], 
     title = typeset("Velocity ", theta__1(t)),labels = [typeset(t), typeset(rad/s)],size = [800, 500]):
B := plot(subs(sol_kine, data, theta_base, vel_s), T = 0..3*actuation_time, color = c_set[2], 
     title = typeset("Velocity ", s(t)),labels = [typeset(t), typeset(m/s)],size = [800, 500]):

plots[display](Array([A, B])):
print(%):

# Singular configurations
det_JPhiD := simplify(Determinant(JPhiD));
# Look for analytic singular configurations
printf("\nThe singular configurations are"):
sol_SCs := solve(Phi union [det_JPhiD], q_vars,explicit=true): print(<%>);
# We check the singular configurations with the avaiable data
printf("\nCheck if the singular configurations can be reached"):
map2(subs,data,{sol_SCs}): print(<op(%)>);
# Acceleration
printf("\nThe accelerations are"):
diff(Phi, t, t):

if mode = 1 then
sol_acc := solve(%, diff(q_D, t, t)):
else 
sol_acc := op(solve(%, diff(q_D, t, t))):
end if:

acc_theta1 := simplify(subs(sol_acc,diff(theta1(t),t,t)));
acc_s      := simplify(subs(sol_acc,diff(s(t),t,t)));

A := plot(subs(sol_kine, data, theta_base, acc_theta1), T = 0..3*actuation_time, color = c_set[1], 
     title = typeset("Acceleration ", theta__1(t)),labels = [typeset(t), typeset(rad/s^2)],size = [800, 500]):
B := plot(subs(sol_kine, data, theta_base, acc_s), T = 0..3*actuation_time, color = c_set[2], 
     title = typeset("Acceleration ", s(t)),labels = [typeset(t), typeset(m/s^2)],size = [800, 500]):

plots[display](Array([A, B])):
print(%):
# Initial conditions
dof0 := theta3(t)=flap_closed;
vel_dof0 := diff(theta3(t),t) = 0;
printf("\nAccording to the initial angle values"):
print(%%,%):

qD0 := op(evalf(subs(dof0, data, sol_kine))): <%>;
vel_qD0 := op(subs(vel_dof0, dof0, data, [sol_vel])): <%>;
printf("\nThe initial configuration is"):
ics0 := [dof0, vel_dof0, qD0, vel_qD0];
print(<%>):
