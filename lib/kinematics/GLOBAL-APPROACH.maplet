
with(MBSymba_r6):
with(LinearAlgebra):

# GLOBAL APPROACH
P0   := origin(ground):
P011 := make_POINT(ground,x1,y1,0):
P40  := make_POINT(ground,x4,y4,0):

printf("\nReference frame 1"):  
RF1  := combine(translate(x0(t),y0(t),0).rotate('Z',theta0(t))):
P01  := origin(%):
Gact := make_POINT(RF1,(s(t)+L1)/2,0,0):
P1   := make_POINT(RF1,s(t),0,0):
P2   := make_POINT(RF1,s(t)+L1,0,0):
print(RF1):



printf("\nReference frame 2"):  
RF2  := combine(translate(x2(t),y2(t),0).rotate('Z',theta1(t))):
Gpod := origin(%):
P22  := make_POINT(RF2,-LP/2,0,0):
P3   := make_POINT(RF2, LP/2,0,0): 
print(RF2):

printf("\nReference frame 3"):  
RF3 := combine(translate(x3(t),y3(t),0).rotate('Z',theta3(t))):
P4  := origin(%):
P3b := make_POINT(RF3,anc,0,0):
P5  := make_POINT(RF3,LF,0,0):
Gflap := make_POINT(RF3.rotate('Z',psi),LFb,0,0):
print(RF3):

# Constraint equations
# Constraint equations : prismatic joint in P1
join_points(P011,P01):                            
Phi1 := map(simplify,[comp_X(%,ground),comp_Y(%,ground)]):

# Constraint equations : revolute joint in P2
join_points(P2,P22):                              
Phi2 := map(simplify,[comp_X(%,ground),comp_Y(%,ground)]):

# Constraint equations : revolute joint in P3
join_points(P3,P3b):                              
Phi3 := map(simplify,[comp_X(%,ground),comp_Y(%,ground)]):

# Constraint equations : revolute joint in P4
join_points(P4,P40):                              
Phi4 := map(simplify,[comp_X(%,ground),comp_Y(%,ground)]):

# Constraint equations: prismatic joint in RF1
Phi5 := [dot_prod(uvec_Y(RF1),uvec_X(ground))]:

# Assembling the constraint equations
printf("\nThe constraint equations are"):  
Phi := Phi1 union Phi2 union Phi3 union Phi4 union Phi5: print(<Phi>):

# Define the list of variables
printf("\nKinematics variables"):  
q_vars := {theta0(t),theta1(t),theta3(t),s(t),x0(t),y0(t),x2(t),y2(t),x3(t),y3(t)}:
print(%):
# Check the DOFs of the system
# Check jacobian of constraints for consistency
printf("\nCheck the consistency of the system (Implict function theorem)"):
combine(jacobianF(Phi, q_vars));  Dimensions(%);
combine(GaussianElimination(%%)); Dimensions(%);

# the system is consistent so i can apply the general formula to compute the degree of freedom of a body
;
# Number of degree of freedom
nq := nops(q_vars):
nc := nops(Phi):

printf("\nThe DOFs of the system are"):
n_dof = nq - nc;
# Analytic solution
q_I := {theta3(t)}:
q_D := q_vars minus q_I;

printf("Analytic solution"):
sol_kine_all := op(solve(Phi, convert(q_D,list), explicit=true)): <%>;

printf("Let's find the right configuration, evaluating the solutions for %a=%f",theta3(t),flap_closed):
evalf(subs(data,param_not_opt, theta3(t)=flap_closed, sol_kine_all[1]));
evalf(subs(data,param_not_opt, theta3(t)=flap_closed, sol_kine_all[2]));
evalf(subs(data,param_not_opt, theta3(t)=flap_closed, sol_kine_all[3]));
evalf(subs(data,param_not_opt, theta3(t)=flap_closed, sol_kine_all[4]));

sol_kine := sol_kine_all[1]:
read("./lib/kinematics/OPTIMIZATION.maplet"):
read("./lib/kinematics/PVAanalysis.maplet"):
