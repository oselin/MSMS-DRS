
with(MBSymba_r6):
with(LinearAlgebra):

# Desidered motion profile for theta3(t)
base_profile := piecewise(
         T >= 0 and T <= T1, -qin - 0.091666666 * sin(41.8879020478638 * T) + 1.2222222 * Pi * T,
         T > T1 and T <= T2, -qin + 0.575958653158127,
         T > T2 and T <= T3, -qin + 0.575958653158127 + 0.091666666 * sin(41.8879020478638 * T -12.5663706143591) - 1.2222222 * Pi * (T - 0.3)):

printf("\nThe desidered motion for theta3(t) is"):
q1_profile := subs(T1 = actuation_time, T2 = 2*actuation_time, T3 = 3*actuation_time, qin = flap_closed, -base_profile):
print(%):

plot(q1_profile * 180/Pi, T = 0..3*actuation_time, title = "Time function for theta3(t)", labels = [t (s), typeset(Angle , " (°)")]):
print(%):
# Desidered motion profile for s(t)
bp := piecewise(T>=0 and T<=T1/2, qin+(1/2)*acc*(T)^2,T>T1/2 and T<=T1, qin+(acc*T1^2)/4-(1/2)*acc*(T1-T)^2):

#Automatically find the needed acceleration to obtain the right motion profile
solve(evalf(subs(qin=s__closed,T1=actuation_time,T=actuation_time,bp))-0,acc):

printf("\nThe desidered (generic) motion for s(t) is"):
Fd_s := subs(qin = s__closed,T1=actuation_time,acc=%,bp):
print(%):
# Kinematic optimization
printf("\nThe parameters to be optimized are"):
prj_params := convert(map(lhs,param_not_opt),list):
print(%):
# Sampling the desidered motion with NP points
printf("\nNumber of points on which estimate the error:"):
np := 100;
print(%):

#Sampling the points
delta__theta3 := [seq(evalf(subs(T=i/np*actuation_time,q1_profile)),i=1..np)]:
delta__s      := [seq(evalf(subs(T=i/np*actuation_time,Fd_s)),i=1..np)]:

#Plotting the sampled points
printf("\nSampled desidered motion"):
[seq([i,delta__theta3[i]],i=1..np)]:
plot(%,style=point,title="Sampled desidered motion for theta3(t)",labels=[points,theta3]):
print(%):
# Weights for optimization
printf("\nLet's introdce a weighting function to give more importance to specific portions of the movement"):
mygauss := -1/(sigma*(2*Pi))*a*exp(1)^(-1/2*(T-mu)^2/sigma):
print(%):

#Find parameters a, mu, sigma such that the curve fits the desidered points
solve([subs(T=1/6*actuation_time,mygauss)-1,
       subs(T=5/6*actuation_time,mygauss)-1,
       subs(T=1/2*actuation_time,mygauss)-0.3],
      {sigma,mu,a}):

weights := subs(T1=actuation_time,piecewise(T>=0      and T<1/6*T1, 1,
                                            T>=1/6*T1 and T<5/6*T1, subs(%,mygauss),
                                            T>=5/6*T1             , 1)):

plot(weights,T=0..actuation_time,y=0..1.1,labels=[typeset(),Weights]):
print(%):
delta__w      := [seq(evalf(subs(T=i/np*actuation_time,weights)),i=1..np)]:
W := add(delta__w[k]^2,k=1..np);

printf("\nThe sampled weighting function is"):
[seq([i,delta__w[i]],i=1..np)]:
plot(%,style=point,title="Sampled desidered weights",labels=[points,w]):
print(%):
# Cost function
#cost function as the summation of errors between the desidered motion and the actual one
cost_fun :=1/W*add(subs(sol_kine,theta3(t)=delta__theta3[k],data,1/2*delta__w[k]^2*(delta__s[k]-s(t))^2),k=1..np):

# Penalties
printf("\nDefinition of the penalties function"):
penalties := (min(L1,0)^2) +
             0.2*(min(LP,0)^2) +
             0.2*(max(anc-0.05,0)^2 + max(LF-anc,0)^2) + 
             0.2*(max(s__closed,0)^2 + max(0.1-s__closed,0)^2) + 
             0.2*(max(0.05-x1,0)^2) + 
             0.2*(max(y1-0.2,0)^2):
print(%):

Optimization:-NLPSolve(cost_fun,
                      {x1<=0.05,y1>=0.2,anc>=0.05,s__closed>=0},
                      initialpoint=param_not_opt,
                      L1=0..0.03,LP=0.1..0.15
                      ):
printf("\nThe optimized parameters are"):
param_opt := convert(%[2],set):print(<op(%)>):
data := data union param_opt:
